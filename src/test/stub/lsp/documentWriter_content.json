[
    {
        "line": 106,
        "character": 0,
        "queryLine": 106,
        "queryCharacrer": 2,
        "functionName": "DocumentsWriter",
        "firstLine": "  DocumentsWriter(",
        "functionContent": "  DocumentsWriter(\n      FlushNotifications flushNotifications,\n      int indexCreatedVersionMajor,\n      AtomicLong pendingNumDocs,\n      boolean enableTestPoints,\n      Supplier<String> segmentNameSupplier,\n      LiveIndexWriterConfig config,\n      Directory directoryOrig,\n      Directory directory,\n      FieldInfos.FieldNumbers globalFieldNumberMap) {\n    this.config = config;\n    this.infoStream = config.getInfoStream();\n    this.deleteQueue = new DocumentsWriterDeleteQueue(infoStream);\n    this.perThreadPool =\n        new DocumentsWriterPerThreadPool(\n            () -> {\n              final FieldInfos.Builder infos = new FieldInfos.Builder(globalFieldNumberMap);\n              return new DocumentsWriterPerThread(\n                  indexCreatedVersionMajor,\n                  segmentNameSupplier.get(),\n                  directoryOrig,\n                  directory,\n                  config,\n                  deleteQueue,\n                  infos,\n                  pendingNumDocs,\n                  enableTestPoints);\n            });\n    this.pendingNumDocs = pendingNumDocs;\n    flushControl = new DocumentsWriterFlushControl(this, config);\n    this.flushNotifications = flushNotifications;\n  }"
    },
    {
        "line": 210,
        "character": 0,
        "queryLine": 210,
        "queryCharacrer": 20,
        "functionName": "abort",
        "firstLine": "  synchronized void abort() throws IOException {",
        "functionContent": "  synchronized void abort() throws IOException {\n    try {\n      deleteQueue.clear();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n      for (final DocumentsWriterPerThread perThread : perThreadPool.filterAndLock(_ -> true)) {\n        try {\n          abortDocumentsWriterPerThread(perThread);\n        } finally {\n          perThread.unlock();\n        }\n      }\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n\n      assert perThreadPool.size() == 0\n          : \"There are still active DWPT in the pool: \" + perThreadPool.size();\n      assert flushControl.getFlushingBytes() == 0\n          : \"flushingBytes has unexpected value 0 != \" + flushControl.getFlushingBytes();\n      assert flushControl.netBytes() == 0\n          : \"netBytes has unexpected value 0 != \" + flushControl.netBytes();\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=true\");\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort success=false\");\n      }\n      throw t;\n    }\n  }"
    },
    {
        "line": 264,
        "character": 0,
        "queryLine": 264,
        "queryCharacrer": 25,
        "functionName": "lockAndAbortAll",
        "firstLine": "  synchronized Closeable lockAndAbortAll() throws IOException {",
        "functionContent": "  synchronized Closeable lockAndAbortAll() throws IOException {\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"lockAndAbortAll\");\n    }\n    // Make sure we move all pending tickets into the flush queue:\n    ticketQueue.forcePurge(\n        ticket -> {\n          if (ticket.getFlushedSegment() != null) {\n            pendingNumDocs.addAndGet(-ticket.getFlushedSegment().segmentInfo.info.maxDoc());\n          }\n        });\n    List<DocumentsWriterPerThread> writers = new ArrayList<>();\n    AtomicBoolean released = new AtomicBoolean(false);\n    final Closeable release =\n        () -> {\n          // we return this closure to unlock all writers once done\n          // or if hit an exception below in the try block.\n          // we can't assign this later otherwise the ref can't be final\n          if (released.compareAndSet(false, true)) { // only once\n            if (infoStream.isEnabled(\"DW\")) {\n              infoStream.message(\"DW\", \"unlockAllAbortedThread\");\n            }\n            perThreadPool.unlockNewWriters();\n            for (DocumentsWriterPerThread writer : writers) {\n              writer.unlock();\n            }\n          }\n        };\n    try {\n      deleteQueue.clear();\n      perThreadPool.lockNewWriters();\n      writers.addAll(perThreadPool.filterAndLock(_ -> true));\n      for (final DocumentsWriterPerThread perThread : writers) {\n        assert perThread.isHeldByCurrentThread();\n        abortDocumentsWriterPerThread(perThread);\n      }\n      deleteQueue.clear();\n\n      // jump over any possible in flight ops:\n      deleteQueue.skipSequenceNumbers(perThreadPool.size() + 1);\n\n      flushControl.abortPendingFlushes();\n      flushControl.waitForFlush();\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"finished lockAndAbortAll success=true\");\n      }\n      return release;\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"finished lockAndAbortAll success=false\");\n      }\n      try {\n        // if something happens here we unlock all states again\n        release.close();\n      } catch (Throwable t1) {\n        t.addSuppressed(t1);\n      }\n      throw t;\n    }\n  }"
    },
    {
        "line": 410,
        "character": 0,
        "queryLine": 410,
        "queryCharacrer": 7,
        "functionName": "updateDocuments",
        "firstLine": "  long updateDocuments(",
        "functionContent": "  long updateDocuments(\n      final Iterable<? extends Iterable<? extends IndexableField>> docs,\n      final DocumentsWriterDeleteQueue.Node<?> delNode)\n      throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      try {\n        seqNo =\n            dwpt.updateDocuments(docs, delNode, flushNotifications, numDocsInRAM::incrementAndGet);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(dwpt);\n    } finally {\n      // If a flush is occurring, we don't want to allow this dwpt to be reused\n      // If it is aborted, we shouldn't allow it to be reused\n      // If the deleteQueue is advanced, this means the maximum seqNo has been set and it cannot be\n      // reused\n      synchronized (flushControl) {\n        if (dwpt.isFlushPending() || dwpt.isAborted() || dwpt.isQueueAdvanced()) {\n          dwpt.unlock();\n        } else {\n          perThreadPool.marksAsFreeAndUnlock(dwpt);\n        }\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }"
    },
    {
        "line": 463,
        "character": 0,
        "queryLine": 463,
        "queryCharacrer": 15,
        "functionName": "doFlush",
        "firstLine": "  private void doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {",
        "functionContent": "  private void doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    assert flushingDWPT != null : \"Flushing DWPT must not be null\";\n    do {\n      assert flushingDWPT.hasFlushed() == false;\n      DocumentsWriterFlushQueue.FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n                || flushingDWPT.deleteQueue == currentFullFlushDelQueue\n            : \"expected: \"\n                + currentFullFlushDelQueue\n                + \" but was: \"\n                + flushingDWPT.deleteQueue\n                + \" \"\n                + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         *\n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to delete documents in 'A'.\n         */\n        try {\n          assert assertTicketQueueModification(flushingDWPT.deleteQueue);\n          final DocumentsWriterPerThread dwpt = flushingDWPT;\n          // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n          ticket =\n              ticketQueue.addTicket(\n                  () -> new DocumentsWriterFlushQueue.FlushTicket(dwpt.prepareFlush(), true));\n          final int flushingDocsInRam = flushingDWPT.getNumDocsInRAM();\n          boolean dwptSuccess = false;\n          try {\n            // flush concurrently without locking\n            final FlushedSegment newSegment = flushingDWPT.flush(flushNotifications);\n            ticketQueue.addSegment(ticket, newSegment);\n            dwptSuccess = true;\n          } finally {\n            subtractFlushedNumDocs(flushingDocsInRam);\n            if (flushingDWPT.pendingFilesToDelete().isEmpty() == false) {\n              Set<String> files = flushingDWPT.pendingFilesToDelete();\n              flushNotifications.deleteUnusedFiles(files);\n            }\n            if (dwptSuccess == false) {\n              flushNotifications.flushFailed(flushingDWPT.getSegmentInfo());\n            }\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the\n          // ticket!\n        } catch (Throwable t) {\n          if (ticket != null) {\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed since the flush\n            // ticket could hold global deletes see FlushTicket#canPublish()\n            ticketQueue.markTicketFailed(ticket);\n          }\n          throw t;\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        if (ticketQueue.getTicketCount() >= perThreadPool.size()) {\n          // This means there is a backlog: the one\n          // thread in innerPurge can't keep up with all\n          // other threads flushing segments.  In this case\n          // we forcefully stall the producers.\n          flushNotifications.onTicketBacklog();\n        }\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n      }\n    } while ((flushingDWPT = flushControl.nextPendingFlush()) != null);\n    flushNotifications.afterSegmentsFlushed();\n  }"
    },
    {
        "line": 628,
        "character": 0,
        "queryLine": 628,
        "queryCharacrer": 7,
        "functionName": "flushAllThreads",
        "firstLine": "  long flushAllThreads() throws IOException {",
        "functionContent": "  long flushAllThreads() throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n\n    boolean anythingFlushed = false;\n    try {\n      anythingFlushed |= maybeFlush();\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();\n      if (anythingFlushed == false\n          && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\n              \"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        assert assertTicketQueueModification(flushingDeleteQueue);\n        ticketQueue.addTicket(() -> maybeFreezeGlobalBuffer(flushingDeleteQueue));\n      }\n      // we can't assert that we don't have any tickets in the queue since we might add a\n      // DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n      flushingDeleteQueue\n          .close(); // all DWPT have been processed and this queue has been fully flushed to the\n      // ticket-queue\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }"
    }
]